from django.db import models

#TODO: Possibly want to Add a model for Annotations that span tiles. I could also see this working as a function
#TODO: Add lift-over information/function for Tile?
#TODO: Consider adding pointer to png for Tile
#TODO: Possibly add color variant is associated with for TileVariant

class TileManage(models.Manager):
    def get_by_natural_key(self, name):
        return self.get(tilename=name)

class Tile(models.Model):
    """This implementation might benefit from verbose_name field additions
    
    Implements a Tile object. The tilename given must be unique and
    in integer format (not hex)

    tilename: integer of the 9 digit hexidecimal identifier for the tile
        First 3 digits of the hexidecimal identifier indicate the band
        Next 2 digits indicate the path
        Next 4 digits indicate the tile

    This representation guarantees that the supertile, path, and tile ID
    will be present in any tile

    startTag: start Tag (24 character limit)
    endTag: end Tag (24 character limit)

    visualization: CommaSeparatedIntegerField, currently allowed to be blank
        because visualization indices can vary without the tile information varying.
        (A,B,C,D): A is x position (which tile in the band), B is y position (which band),
            C is number of pixels along the x-axis the tile covers, D is the number of pixels
            along the y-axis the tile covers

    created: When the tile was generated

    TODO: possible pointer to png
    """
    tilename = models.BigIntegerField(primary_key=True) 
    startTag = models.CharField(max_length=24)
    endTag = models.CharField(max_length=24)
    visualization = models.CommaSeparatedIntegerField(max_length=4, blank=True)
    created = models.DateField(auto_now_add=True)
    
    def getTileString(self):
        """Displays hex indexing for tile """
        strTilename = hex(self.tilename)[2:-1]
        strTilename = strTilename.zfill(9)
        supertile = strTilename[:3]
        path = strTilename[3:5]
        tile = strTilename[5:]
        return supertile + "." + path + "." + tile + ".00"
    getTileString.short_description='Tile Name'
    def __unicode__(self):
        return self.getTileString()
    class Meta:
        ordering = ['tilename']

class TileVariant(models.Model):
    """
    Implements a TileVariant. Each Tile can have many TileVariants. The reference tile is also termed a TileVariant

    tile: The parent tile

    reference: (Boolean) is this the reference tile according to the reference genome

    length: Length of the tile in bases

    populationSize: number of people in the saved population who have this tile

    startTag: only present if the startTag varies from tile.startTag
    endTag: only present if the endTag varies from tile.endTag

    sequence: the sequence of the tile

    md5sum: (CharField) the hash for the TileVariant
    
    TODO: color of visualization
    """

    tile = models.ForeignKey(Tile, related_name='variants')
    reference = models.BooleanField()
    length = models.PositiveIntegerField()
    populationSize = models.BigIntegerField()
    startTag = models.TextField(blank=True)
    endTag = models.TextField(blank=True)
    sequence = models.TextField()
    md5sum = models.CharField(max_length=40)
    lastModified = models.DateField(auto_now=True)
    #color = models
    def getPosition(self):
        allVariants = sorted(self.tile.variants.all(), key=lambda var: var.populationSize)
        return str(allVariants.index(self))
    def getVarString(self):
        #Currently assumes that Default will always be highly popualted
        #Also assumes getPosition works...
        if self.reference:
            return self.tile.getTileString() + ": Reference"
        else:
            return self.tile.getTileString() + ": Variant " + self.getPosition()
    def __unicode__(self):
        return self.getVarString()

class TileVarAnnotation(models.Model):
    """Model of Annotations on TileVariants
    Currently one-to-many relation with TileVariant
    
    annotationType indicates what the annotation describes; TYPE_CHOICES is ordered
        by proximity to the DNA sequence
    trusted indicates whether the annotation was generated by a user or the code.
        Could change trusted to a Field that supports choices to have a wider range
        of possible sources: the code that generated it vs people, etc
    annotationText is the text field of the annotation. Currently, it is completely
        unorganized, which will slow queries down

    """
    SNP_OR_INDEL = 'SNP_INDEL'
    DNA_MODIFICATION = 'DNA_MOD'
    BINDING_SITE = 'BIND'
    PROMOTER = 'PRO'
    EXON_OR_INTRON = 'EXON'
    RNA = 'RNA'
    GENE_PROTEIN = 'GENE'
    HISTONE = 'HIST'
    CHROMATIN_INFORMATION = 'CHROMATIN'
    GROSS_PHENOTYPE = 'PHEN'
    OTHER = 'OTHER'
    TYPE_CHOICES = (
        (SNP_OR_INDEL, 'SNP or Insert/Deletion Annotation'),
        (DNA_MODIFICATION, 'DNA Modification Annotation'),
        (BINDING_SITE, 'Protein Binding Site Annotation'),
        (PROMOTER, 'Promoter region Annotation'),
        (EXON_OR_INTRON, 'Exon or Intron Annotation'),
        (RNA, 'RNA (including smRNA and mRNA) Annotation'),
        (GENE_PROTEIN, 'Gene and Protein-related Annotation'),
        (HISTONE, 'Histone modification Annotation'),
        (CHROMATIN_INFORMATION, 'Chromatin Annotation'),
        (GROSS_PHENOTYPE, 'Phenotype Annotation'),
        (OTHER, 'Other Type of Annotation'),
    )
    tileVariant = models.ForeignKey(TileVariant, related_name='annotations')
    annotationType = models.CharField(max_length=10, choices=TYPE_CHOICES)
    trusted = models.BooleanField()
    annotationText = models.TextField()
    created = models.DateField(auto_now_add=True)
    lastModified = models.DateField(auto_now=True)
    def __unicode__(self):
        typeIndex = [i for i,j in self.TYPE_CHOICES]
        humanReadable = self.TYPE_CHOICES[typeIndex.index(self.annotationType)][1]
        return humanReadable + ' for ' +  self.tileVariant.getVarString()

class locusAnnotation(models.Model):
    """Abstract Model of translations between assembly and tiles
    assembly is the integer mapping to the name of the assembly
    chromosome is the integer mapping to the name of the chromosome the tile is associated with
    beginning is the integer for the beginning
    ending is the integer for the ending
    chromosome_name is the text for the name of the chromosome if chromosome=26 (OTHER)
    """
    ASSEMBLY_16 = 16
    ASSEMBLY_17 = 17
    ASSEMBLY_18 = 18
    ASSEMBLY_19 = 19
    ASSEMBLY_38 = 38
    SUPPORTED_ASSEMBLY_CHOICES = (
        (ASSEMBLY_16, 'NCBI34/hg16'),
        (ASSEMBLY_17, 'NCBI35/hg17'),
        (ASSEMBLY_18, 'NCBI36/hg18'),
        (ASSEMBLY_19, 'GRCh37/hg19'),
        (ASSEMBLY_38, 'GRCh38/hg38'),
    )
    CHR_1 = 1
    CHR_2 = 2
    CHR_3 = 3
    CHR_4 = 4
    CHR_5 = 5
    CHR_6 = 6
    CHR_7 = 7
    CHR_8 = 8
    CHR_9 = 9
    CHR_10 = 10
    CHR_11 = 11
    CHR_12 = 12
    CHR_13 = 13
    CHR_14 = 14
    CHR_15 = 15
    CHR_16 = 16
    CHR_17 = 17
    CHR_18 = 18
    CHR_19 = 19
    CHR_20 = 20
    CHR_21 = 21
    CHR_22 = 22
    CHR_X = 23
    CHR_Y = 24
    CHR_M = 25
    OTHER = 26
    CHR_CHOICES = (
        (CHR_1, 'chr1'),
        (CHR_2, 'chr2'),
        (CHR_3, 'chr3'),
        (CHR_4, 'chr4'),
        (CHR_5, 'chr5'),
        (CHR_6, 'chr6'),
        (CHR_7, 'chr7'),
        (CHR_8, 'chr8'),
        (CHR_9, 'chr9'),
        (CHR_10, 'chr10'),
        (CHR_11, 'chr11'),
        (CHR_12, 'chr12'),
        (CHR_13, 'chr13'),
        (CHR_14, 'chr14'),
        (CHR_15, 'chr15'),
        (CHR_16, 'chr16'),
        (CHR_17, 'chr17'),
        (CHR_18, 'chr18'),
        (CHR_19, 'chr19'),
        (CHR_20, 'chr20'),
        (CHR_21, 'chr21'),
        (CHR_22, 'chr22'),
        (CHR_X, 'chrX'),
        (CHR_Y, 'chrY'),
        (CHR_M, 'chrM'),
        (OTHER, 'Other'),
    )
    assembly= models.PositiveSmallIntegerField(choices=SUPPORTED_ASSEMBLY_CHOICES)
    chromosome = models.PositiveSmallIntegerField(choices=CHR_CHOICES)
    beginning = models.PositiveIntegerField()
    end = models.PositiveIntegerField()
    chromosomeName = models.CharField(max_length=100)
    class Meta:
        abstract = True


class varLocusAnnotation(locusAnnotation):
    """Model of translations for a TileVariant
    locus_annotations is the related name for these types of annotations
    """
    tilevar = models.ForeignKey(TileVariant, related_name="locus_annotations")


class tileLocusAnnotation(locusAnnotation):
    """Model of translations for a Tile
    tile_locus_annotations is the related name for these types of annotations
    """
    tile = models.ForeignKey(Tile, related_name="tile_locus_annotations")


    
